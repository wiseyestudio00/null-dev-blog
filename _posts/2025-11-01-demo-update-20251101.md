---
title: "Lily Fantasia / Demo Update 2025-11-01"
date: 2025-11-01 16:00:00 +0800
author: null_id
categories: [tecnical]
tag: [code, lilyfantasia]
media_subpath: /assets/posts/demo-update-2025-11-01/
CJKmainfont: Hiragino Sans GB
---

## Introduction
Every program in existence is just 2 concepts: a bunch of if statements and for-loops. The only difference is how you implement those ifs and fors, and the only correct way to do so is the various ways of Dependency Injection.

## Leaderboard
I have been yapping about implementing leaderboards in Lily Fantasia for the past few weeks. I estimated it will take around 2 weeks to implement such feature. At the end, it took about 1 week or so.

![songlist](songlist.jpg)

Now, when you enter the Song List Menu, there is an additional Control Sprite telling you to press E to view Leaderboard.

![leaderboad](leaderboard.jpg)

On the top, you will see your best score for the chart selected, along with the time you achieved the best score.

There will be 3 leaderboards for each Chart for each Song: Global, Friends, Local. If you are playing on Steam, the game will use Steam's built-in service to record the scores. In other words, Global leaderboard on Steam will contain the high scores from players that are also on the Steam platform. Suppose Lily Fantasia is ported to other platforms in the future, each version will likely have its own separate leaderboards limited to that platformâ€™s players.

Needless to say, Local is a special leaderboard that only displays your high scores on the device, so you can view your best plays and when they happened too.

![leaderboard local](leaderboard_local.jpg)

Up to 20 plays will be displayed for each leaderboard at a time.

Let's talk more about the Profile Picture and player name. Currently, player name is default to Steam's username, and their Profile Picture is also default to their Steam Avatar. Of course, the players can choose to change their Profile Picture in game. However, due to how Steam allows players to fecth other players' information, the Profile Picture in-game will only be shown if:

1. The player is also a friend with you on Steam
2. or, the player has set their profile public

Only under these circumstances could their in-game Profile Picture be shown. Otherwise the Leaderboard can only show their Steam Avatar even if they have set their Profile Pciture in-game.

## Steamworks
Let's talk about implementing Steamworks feature in Unity (or, in general, C#).

Although Steam provides a native C++ librarys to the game devs, since Unity uses C#, you can not directly use Steam's SDK in your game. You have to use a plugin that allows you to access those functionalities in the SDK.

From what I know, there are 2 major plugins you can use: either [Facepunch](https://wiki.facepunch.com/steamworks/)'s implementation, or [Steamworks.Net](https://steamworks.github.io/)'s.

In general, Facepunch provides a more "mordern" async await implementation to Steam's functionalities, while Steamworks.Net is almost a 1:1 implementation of the original Steam's C++ SDK, which is event based.

I strongly prefer Facepunch's async await style of calling methods. However, it has one glaring issue: for some reason, Facepunch's plugin does not have a corresponding method to Steam's UserStat.RequestUserStats() function. This means we would not be able to fech other players' information, even if the players are friends with each other. Since I want to display custom Profile Picture, which is stored as a UserStat on Steam's backend, I would not be able to use Facepunch's plugin.

On the other hand, Steamworks.Net has 2 glaring issues. First of all, because it uses Preporcessor Symbols to exclude its code from platforms that do not support Steam, none of its method will be compied on those platforms. That is to say, if I just call its method directly on.......let's say Nintendo Switch version of the game, the game would not even compile. And also, it's entirely event-based, which I dislike.

| Facepunch                        | Steamworks.Net                          |
| -------------------------------- | --------------------------------------- |
| async await                      | Event                                   |
| Compilable on non-Steam platform | Would not compile on non-Steam platform |

However, since Steamworks.Net is the only option, I have to work with it somehow. I think this means I would need to create a wrapper around Steamworks.Net's methods, to 1, convert the events into async await functions, and 2, make those functions compilable on non-Steam platforms.

After some work, I landed on this implementation.


```csharp
#if UNITY_STANDALONE_WIN || UNITY_STANDALONE_LINUX || UNITY_STANDALONE_OSX || STEAMWORKS_WIN || STEAMWORKS_LIN_OSX
#define ENABLE_STEAMWORKS
#endif

using System;
using System.Threading;
using Cysharp.Threading.Tasks;
using UnityEngine;

#if ENABLE_STEAMWORKS
using Steamworks;
#endif

namespace WiseyeStudio.Steam
{
    public class SteamPlayerManager : IDisposable
    {
#if ENABLE_STEAMWORKS
        private readonly Callback<UserStatsStored_t> _userStatsStoredCallback; 
        private UniTaskCompletionSource<UserStatsStored_t> _userStatsStoredTcs;
#endif
        
        internal SteamPlayerManager()
        {
#if ENABLE_STEAMWORKS
            _userStatsStoredCallback = Callback<UserStatsStored_t>.Create(OnUserStatsStored);
#endif
        }

        public ulong GetSteamId()
        {
#if ENABLE_STEAMWORKS
            return SteamUser.GetSteamID().m_SteamID;
#endif
            return 0;
        }
        
        public string GetName()
        {
#if ENABLE_STEAMWORKS
            return SteamworksManager.Instance.Available ? SteamFriends.GetPersonaName() : string.Empty;
#endif
            return String.Empty;
        }

        public bool LoggedOn()
        {
#if ENABLE_STEAMWORKS
            return SteamworksManager.Instance.Available && SteamUser.BLoggedOn();
#endif
            return false;
        }

        private Sprite _avatarSprite;
        private async UniTask LazyLoadAvatarAsync(CancellationToken cancellationToken)
        {
#if ENABLE_STEAMWORKS
            if (_avatarSprite != null)
            {
                return;
            }
            
            try
            {
                var userSteamId = SteamUser.GetSteamID();
                using var loader = new SteamAvatarLoader(userSteamId);
                _avatarSprite = await loader.LoadPfpAsync(cancellationToken);
            }
            catch ( Exception e )
            {
                // If something goes wrong, log it
                Debug.Log( e );
            }
#endif
            await UniTask.CompletedTask;
        }

        public async UniTask<Sprite> GetSteamAvatarAsSpriteAsync(CancellationToken cancellationToken)
        {
#if ENABLE_STEAMWORKS
            await LazyLoadAvatarAsync(cancellationToken);
            return _avatarSprite;
#endif
            return null;
        }

        internal bool GetStat(string statName, out int stat)
        {
#if ENABLE_STEAMWORKS
            return SteamUserStats.GetStat(statName, out stat);
#endif
            stat = -1;
            return false;
        }

        internal bool GetStat(string statName, out float stat)
        {
#if ENABLE_STEAMWORKS
            return SteamUserStats.GetStat(statName, out stat);
#endif
            stat = -1f;
            return false;
        }

        public UniTask<bool> SetStatAsync(string statName, int value, CancellationToken cancellationToken)
        {
#if ENABLE_STEAMWORKS
            // This call is no longer required, as it is handled in SteamClient.Init, at least from 2025.162.1
            // SteamUserStats.RequestCurrentStats()
            return UniTask.FromResult(SteamUserStats.SetStat(statName, value));
#endif
            return UniTask.FromResult(false);
        }

        public UniTask<bool> SetStatAsync(string statName, float value, CancellationToken cancellationToken)
        {
#if ENABLE_STEAMWORKS
            return UniTask.FromResult(SteamUserStats.SetStat(statName, value));
#endif
            return UniTask.FromResult(false);
        }

        public async UniTask<bool> StoreStatAsync(CancellationToken cancellationToken)
        {
#if ENABLE_STEAMWORKS
            await UniTaskCompletionSourceUtility.AwaitCompleteIfNotNull(_userStatsStoredTcs, cancellationToken);
            
            _userStatsStoredTcs = new UniTaskCompletionSource<UserStatsStored_t>();

            try
            {
                if (SteamUserStats.StoreStats() == false) return false;
                var callback = await _userStatsStoredTcs.Task.AttachExternalCancellation(cancellationToken);
                var result = callback.m_eResult == EResult.k_EResultOK;
                _userStatsStoredTcs = null;
                return result;
            }
            catch (OperationCanceledException e)
            {
                Debug.LogException(e);
                _userStatsStoredTcs = null;
                return false;
            }
            catch (Exception e)
            {
                Debug.LogException(e);
                _userStatsStoredTcs = null;
                return false;
            }
#endif
            return false;
        }
        
#if ENABLE_STEAMWORKS
        private void OnUserStatsStored(UserStatsStored_t userStatsStored)
        {
            _userStatsStoredTcs?.TrySetResult(userStatsStored);
        }
#endif
        public void Dispose()
        {
#if ENABLE_STEAMWORKS
            _userStatsStoredCallback?.Dispose();
            _userStatsStoredTcs.TrySetCanceled();
#endif
        }
    }
}
```

First of all, notice how although all public methods in this class is available on all platforms, the implementation is wrapped in a Preprocessor so althoguh they can be called, they will simply return an error result, indicating the service is not available. Secondly, take a look at `StoreStatAsync`, which uses a `UniTaskCompletionSource` to convert the wating of the event-call into an `async await` method.

([UniTask](https://github.com/Cysharp/UniTask) is CySharp's imeplementation of Task in Unity, which I recommend to all Unity users.)
(CySharp is apparently a subsidiary of Cygames, which makes Uma Usume, you know, the horse girl racing game)

Using the same principle, I convert all functionalities I need to use right now from Steamworks.net's events to async await functions. I have outputted the wrapper as a [UnityPackage](https://wiseyestudio00.github.io/null-dev-blog/assets/posts/demo-update-2025-11-01/wiseyestudio_steam.unitypackage) for you to download and play around.

When you import the package into your Unity Editor, you will notice it has a bunch of errors. You will need to import [UniTask](https://github.com/Cysharp/UniTask), [Steamworks.Net](https://steamworks.github.io/), and [OdinInspector](https://odininspector.com/) for it to compile. The first 2 are required and open-source, while you can delete the `[Requried]` attributes in `SteamworksManager` to avoid having to purchase Odin Inspector.

## Dependency Injection
Of course, even after I created this wrapper to Steam's functionalities, I still can not directly call this method in Lily Fantasia, since it would make no sense to call a Steam functions when the game is, for example, on Nintendo Switch. This means I need to create another layer to abstract out the game's Service to its implementation.

This is an interesting topic, but I realize not many of you are __THAT__ interested, and I will need to spend like at least half a day explaining all the layers. So here is an incorrect UML Diagram explaining the abstraction.

![LilyFantasiaGameService](LilyFantasiaGameService.png)

Let me know if you are interested for an explanation of the diagram (I say this knowing no one would ask lmao).

## Conclusion
I have been thinking about a possible PvP feature, but I am sure I would not be able to get around to it in time.