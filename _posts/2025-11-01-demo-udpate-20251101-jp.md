---
title: "Lily Fantasia / デモアップデート 2025-11-01"
date: 2025-11-01 16:00:00 +0800
author: null_id
categories: [tecnical]
tag: [code, lilyfantasia]
media_subpath: /assets/posts/demo-update-2025-11-01/
CJKmainfont: Hiragino Sans GB
---

## はじめに
この世に存在するすべてのプログラムは、たった2つの概念でできています：大量のif文とforループです。違いはそれらのifとforをどう実装するかだけで、そして唯一の正しい実装方法は、様々な依存性注入のやり方です。

## リーダーボード
ここ数週間、Lily Fantasiaにリーダーボード機能を実装することについてずっと話してきました。この機能の実装には約2週間かかると見積もっていました。結果的には、1週間ほどで完成しました。

![songlist](songlist.jpg)

楽曲リストメニューに入ると、リーダーボードを見るためにEキーを押すよう案内する追加のコントロールスプライトが表示されます。

![leaderboad](leaderboard.jpg)

上部には、選択した譜面のベストスコアと、そのスコアを達成した時刻が表示されます。

各楽曲の各譜面には3つのリーダーボードがあります：グローバル、フレンド、ローカル。Steamでプレイしている場合、ゲームはSteamの内蔵サービスを使用してスコアを記録します。つまり、Steamのグローバルリーダーボードには、同じくSteamプラットフォームでプレイしているプレイヤーのハイスコアが含まれます。将来Lily Fantasiaが他のプラットフォームに移植された場合、各バージョンはそのプラットフォームのプレイヤーに限定された独自のリーダーボードを持つことになるでしょう。

言うまでもなく、ローカルは特別なリーダーボードで、デバイス上のあなたのハイスコアのみを表示するので、ベストプレイとその達成時刻も確認できます。

![leaderboard local](leaderboard_local.jpg)

各リーダーボードには一度に最大20回のプレイが表示されます。

プロフィール画像とプレイヤー名について詳しく説明しましょう。現在、プレイヤー名はデフォルトでSteamのユーザー名になり、プロフィール画像もSteamアバターがデフォルトになります。もちろん、プレイヤーはゲーム内でプロフィール画像を変更できます。しかし、Steamが他のプレイヤーの情報取得を許可する方法のため、ゲーム内のプロフィール画像は以下の条件でのみ表示されます：

1. そのプレイヤーがSteamであなたのフレンドである
2. または、そのプレイヤーがプロフィールを公開設定にしている

これらの状況でのみ、ゲーム内のプロフィール画像が表示されます。そうでなければ、プレイヤーがゲーム内でプロフィール画像を設定していても、リーダーボードにはSteamアバターのみが表示されます。

## Steamworks
Unity（または一般的にC#）でSteamworks機能を実装することについて話しましょう。

Steamはゲーム開発者にネイティブC++ライブラリを提供していますが、UnityはC#を使用するため、SteamのSDKを直接ゲームで使用することはできません。SDK内の機能にアクセスできるプラグインを使用する必要があります。

私の知る限り、使用できる主要なプラグインは2つあります：[Facepunch](https://wiki.facepunch.com/steamworks/)の実装か、[Steamworks.Net](https://steamworks.github.io/)のどちらかです。

一般的に、FacepunchはSteamの機能に対してより「モダン」なasync await実装を提供し、一方Steamworks.NetはオリジナルのSteam C++ SDKのほぼ1対1の実装で、イベントベースです。

私はFacepunchのasync awaitスタイルのメソッド呼び出しを強く好みます。しかし、重大な問題が1つあります：なぜか、FacepunchのプラグインにはSteamのUserStat.RequestUserStats()関数に対応するメソッドがありません。これは、プレイヤー同士がフレンドであっても、他のプレイヤーの情報を取得できないことを意味します。カスタムプロフィール画像を表示したいと考えており、これはSteamのバックエンドでUserStatとして保存されているため、Facepunchのプラグインを使用できません。

一方、Steamworks.Netには2つの重大な問題があります。まず、プリプロセッサシンボルを使用してSteamをサポートしないプラットフォームからコードを除外するため、それらのプラットフォームではメソッドがコンパイルされません。つまり、例えばNintendo Switch版のゲームでそのメソッドを直接呼び出すと、ゲームはコンパイルすらされません。また、完全にイベントベースであり、これは私の好みではありません。

| Facepunch                               | Steamworks.Net                            |
| --------------------------------------- | ----------------------------------------- |
| async await                             | イベント                                  |
| 非Steamプラットフォームでコンパイル可能 | 非Steamプラットフォームではコンパイル不可 |

しかし、Steamworks.Netが唯一の選択肢であるため、何とか対応する必要があります。これは、Steamworks.Netのメソッドのラッパーを作成する必要があることを意味します。1つ目はイベントをasync await関数に変換すること、2つ目は非Steamプラットフォームでもコンパイル可能にすることです。

いくつか作業した結果、この実装に辿り着きました。

```csharp
#if UNITY_STANDALONE_WIN || UNITY_STANDALONE_LINUX || UNITY_STANDALONE_OSX || STEAMWORKS_WIN || STEAMWORKS_LIN_OSX
#define ENABLE_STEAMWORKS
#endif

using System;
using System.Threading;
using Cysharp.Threading.Tasks;
using UnityEngine;

#if ENABLE_STEAMWORKS
using Steamworks;
#endif

namespace WiseyeStudio.Steam
{
    public class SteamPlayerManager : IDisposable
    {
#if ENABLE_STEAMWORKS
        private readonly Callback<UserStatsStored_t> _userStatsStoredCallback; 
        private UniTaskCompletionSource<UserStatsStored_t> _userStatsStoredTcs;
#endif
        
        internal SteamPlayerManager()
        {
#if ENABLE_STEAMWORKS
            _userStatsStoredCallback = Callback<UserStatsStored_t>.Create(OnUserStatsStored);
#endif
        }

        public ulong GetSteamId()
        {
#if ENABLE_STEAMWORKS
            return SteamUser.GetSteamID().m_SteamID;
#endif
            return 0;
        }
        
        public string GetName()
        {
#if ENABLE_STEAMWORKS
            return SteamworksManager.Instance.Available ? SteamFriends.GetPersonaName() : string.Empty;
#endif
            return String.Empty;
        }

        public bool LoggedOn()
        {
#if ENABLE_STEAMWORKS
            return SteamworksManager.Instance.Available && SteamUser.BLoggedOn();
#endif
            return false;
        }

        private Sprite _avatarSprite;
        private async UniTask LazyLoadAvatarAsync(CancellationToken cancellationToken)
        {
#if ENABLE_STEAMWORKS
            if (_avatarSprite != null)
            {
                return;
            }
            
            try
            {
                var userSteamId = SteamUser.GetSteamID();
                using var loader = new SteamAvatarLoader(userSteamId);
                _avatarSprite = await loader.LoadPfpAsync(cancellationToken);
            }
            catch ( Exception e )
            {
                // If something goes wrong, log it
                Debug.Log( e );
            }
#endif
            await UniTask.CompletedTask;
        }

        public async UniTask<Sprite> GetSteamAvatarAsSpriteAsync(CancellationToken cancellationToken)
        {
#if ENABLE_STEAMWORKS
            await LazyLoadAvatarAsync(cancellationToken);
            return _avatarSprite;
#endif
            return null;
        }

        internal bool GetStat(string statName, out int stat)
        {
#if ENABLE_STEAMWORKS
            return SteamUserStats.GetStat(statName, out stat);
#endif
            stat = -1;
            return false;
        }

        internal bool GetStat(string statName, out float stat)
        {
#if ENABLE_STEAMWORKS
            return SteamUserStats.GetStat(statName, out stat);
#endif
            stat = -1f;
            return false;
        }

        public UniTask<bool> SetStatAsync(string statName, int value, CancellationToken cancellationToken)
        {
#if ENABLE_STEAMWORKS
            // This call is no longer required, as it is handled in SteamClient.Init, at least from 2025.162.1
            // SteamUserStats.RequestCurrentStats()
            return UniTask.FromResult(SteamUserStats.SetStat(statName, value));
#endif
            return UniTask.FromResult(false);
        }

        public UniTask<bool> SetStatAsync(string statName, float value, CancellationToken cancellationToken)
        {
#if ENABLE_STEAMWORKS
            return UniTask.FromResult(SteamUserStats.SetStat(statName, value));
#endif
            return UniTask.FromResult(false);
        }

        public async UniTask<bool> StoreStatAsync(CancellationToken cancellationToken)
        {
#if ENABLE_STEAMWORKS
            await UniTaskCompletionSourceUtility.AwaitCompleteIfNotNull(_userStatsStoredTcs, cancellationToken);
            
            _userStatsStoredTcs = new UniTaskCompletionSource<UserStatsStored_t>();

            try
            {
                if (SteamUserStats.StoreStats() == false) return false;
                var callback = await _userStatsStoredTcs.Task.AttachExternalCancellation(cancellationToken);
                var result = callback.m_eResult == EResult.k_EResultOK;
                _userStatsStoredTcs = null;
                return result;
            }
            catch (OperationCanceledException e)
            {
                Debug.LogException(e);
                _userStatsStoredTcs = null;
                return false;
            }
            catch (Exception e)
            {
                Debug.LogException(e);
                _userStatsStoredTcs = null;
                return false;
            }
#endif
            return false;
        }
        
#if ENABLE_STEAMWORKS
        private void OnUserStatsStored(UserStatsStored_t userStatsStored)
        {
            _userStatsStoredTcs?.TrySetResult(userStatsStored);
        }
#endif
        public void Dispose()
        {
#if ENABLE_STEAMWORKS
            _userStatsStoredCallback?.Dispose();
            _userStatsStoredTcs.TrySetCanceled();
#endif
        }
    }
}
```

まず最初に、このクラスのすべてのパブリックメソッドはすべてのプラットフォームで利用可能ですが、実装はプリプロセッサでラップされているため、呼び出すことはできますが、単にサービスが利用できないことを示すエラー結果を返すだけです。次に、`StoreStatAsync`を見てください。これは`UniTaskCompletionSource`を使用してイベント待機を`async await`メソッドに変換しています。

（[UniTask](https://github.com/Cysharp/UniTask)はCySharpによるUnityでのTask実装で、すべてのUnityユーザーにお勧めします。）
（CySharpは明らかにCygamesの子会社で、ウマ娘を作っている会社ですね、馬の女の子のレースゲームです）

同じ原理を使って、現在使用する必要があるすべての機能をSteamworks.netのイベントからasync await関数に変換しました。ラッパーを[UnityPackage](https://wiseyestudio00.github.io/null-dev-blog/assets/posts/demo-update-2025-11-01/wiseyestudio_steam.unitypackage)として出力したので、ダウンロードして試してみてください。

パッケージをUnity Editorにインポートすると、たくさんのエラーが出ることに気づくでしょう。コンパイルするには[UniTask](https://github.com/Cysharp/UniTask)、[Steamworks.Net](https://steamworks.github.io/)、そして[OdinInspector](https://odininspector.com/)をインポートする必要があります。最初の2つは必須でオープンソースですが、Odin Inspectorを購入しなくても済むように`SteamworksManager`内の`[Required]`属性を削除できます。

## 依存性注入
もちろん、このSteam機能へのラッパーを作成した後でも、Lily Fantasiaで直接このメソッドを呼び出すことはできません。なぜなら、例えばゲームがNintendo Switchで動作している場合、Steam関数を呼び出すのは意味がないからです。つまり、ゲームのサービスをその実装に抽象化するための別のレイヤーを作成する必要があります。

これは興味深いトピックですが、皆さんの多くがそこまで興味があるわけではないことに気づきました。また、すべてのレイヤーを説明するには少なくとも半日は必要でしょう。なので、抽象化を説明する不正確なUML図をここに示します。

![LilyFantasiaGameService](LilyFantasiaGameService.png)

図の説明に興味がある方は教えてください（誰も聞いてこないのは分かってますけどｗ）。

## まとめ
PvP機能について考えていますが、時間内に実装できないのは確実です。