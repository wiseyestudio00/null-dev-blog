---
title: "Lily Fantasia／Demo 更新紀錄 2025-11-01"
date: 2025-11-01 16:00:00 +0800
author: null_id
categories: [technical]
tag: [code, lilyfantasia]
media_subpath: /assets/posts/demo-update-2025-11-01/
CJKmainfont: Hiragino Sans GB
----

## 前言

所有存在的程式其實都只有兩個概念：「一堆 if 判斷式」與「一堆 for 迴圈」。差別只在於你怎麼實作那些 if 與 for，而正確的方式只有一種——那就是各式各樣的 **Dependency Injection（依賴注入）**。

## 排行榜系統

我前幾週一直在提到要為 Lily Fantasia 加入排行榜系統。原本預估大約需要兩週的開發時間，最後實際只花了大約一週左右就完成了。

![songlist](songlist.jpg)

現在，當你進入「歌曲列表」選單時，會看到一個額外的控制提示，告訴你按下 **E 鍵** 以查看排行榜。

![leaderboard](leaderboard.jpg)

在畫面上方，你會看到自己在當前譜面的最高分數，以及達成該分數的時間。

每首歌的每個譜面都有三個排行榜類型：**全球(Global)**、**好友(Friends)**、**本機(Local)**。
如果你是在 Steam 上遊玩，遊戲會使用 Steam 內建的服務來記錄分數。換句話說，Steam 版本的全球排行榜只包含在 Steam 平台上遊玩的玩家。若將來 Lily Fantasia 登上其他平台，各平台將擁有各自獨立的排行榜。

至於「本機排行榜」，則是顯示你在該裝置上達成的所有分數與時間，方便你回顧自己的最佳成績。

![leaderboard local](leaderboard_local.jpg)

每個排行榜最多會顯示 20 條遊玩記錄。

接著談談玩家名稱與大頭貼。目前預設是使用 Steam 的使用者名稱與頭像。當然，玩家也可以在遊戲內更換大頭貼。不過，由於 Steam 對於用戶資料的存取權限有限，遊戲內的自訂頭像僅在以下兩種情況下會顯示：

1. 該玩家是你的 Steam 好友
2. 或該玩家的個人檔案設為公開

若不符合上述條件，即使對方在遊戲中設定了自訂頭像，排行榜上仍只能顯示其 Steam 頭像。

## Steamworks 實作

接下來談談在 Unity（或更廣義地說，在 C#）中實作 Steamworks 功能的過程。

雖然 Steam 提供的是原生 C++ SDK，但由於 Unity 使用 C#，因此無法直接使用該 SDK，必須透過插件才能呼叫其功能。

目前主要有兩個常見的插件可用：

* [Facepunch](https://wiki.facepunch.com/steamworks/)
* [Steamworks.Net](https://steamworks.github.io/)

整體而言，Facepunch 提供了較「現代化」的 `async/await` 非同步實作；
而 Steamworks.Net 幾乎是 Steam 原生 C++ SDK 的一對一映射，採用事件機制。

我個人偏好 Facepunch 的 `async/await` 風格，但它有個致命問題：
它缺乏對 Steam `UserStat.RequestUserStats()` 函數的對應方法，這導致無法存取其他玩家的資料。
由於我希望顯示自訂大頭貼（該資料儲存在 Steam 的使用者統計中），因此無法使用 Facepunch。

相對地，Steamworks.Net 有兩個明顯缺點：
第一，它利用 **前置處理符號 (Preprocessor Symbols)** 來排除不支援 Steam 的平台，導致在非 Steam 平台上連編譯都會失敗。
第二，它完全採事件機制，讓程式架構變得繁瑣。

| Facepunch             | Steamworks.Net        |
| --------------------- | --------------------- |
| async await           | Event 機制            |
| 可在非 Steam 平台編譯 | 非 Steam 平台無法編譯 |

但因為 Steamworks.Net 是唯一可行的選項，只能設法解決。
我的做法是包一層 **Wrapper（封裝層）**，

1. 將事件轉換為 `async/await` 函數；
2. 並確保在非 Steam 平台上仍能編譯（即使功能不可用）。

以下是最終實作版本（完整程式碼見原文）：

```csharp
#if UNITY_STANDALONE_WIN || UNITY_STANDALONE_LINUX || UNITY_STANDALONE_OSX || STEAMWORKS_WIN || STEAMWORKS_LIN_OSX
#define ENABLE_STEAMWORKS
#endif
// ...（完整程式碼略）
```

注意：所有公開方法在所有平台上皆可呼叫，但其內部實作以前置處理符號包住。
若當前平台不支援 Steam，方法僅會回傳錯誤或空結果。
另外，`StoreStatAsync` 利用 `UniTaskCompletionSource` 將事件等待機制轉換為 `async/await`。

（[UniTask](https://github.com/Cysharp/UniTask) 是 CySharp 為 Unity 所設計的 Task 實作，非常推薦使用。
順帶一提，CySharp 是 Cygames 的子公司，也就是製作《賽馬娘》的那家公司。）

我已將這個封裝整理成 [UnityPackage](https://wiseyestudio00.github.io/null-dev-blog/assets/posts/demo-update-2025-11-01/wiseyestudio_steam.unitypackage)，
你可以下載後自行嘗試。

導入後，若 Unity Editor 出現錯誤，請確認已安裝以下套件：

* [UniTask](https://github.com/Cysharp/UniTask)
* [Steamworks.Net](https://steamworks.github.io/)
* [OdinInspector](https://odininspector.com/)

前兩者為必要且開源，若不想購買 Odin Inspector，可刪除 `SteamworksManager` 內的 `[Required]` 標籤即可。

## 依賴注入（Dependency Injection）

即使建立了這層封裝，也不能在 Lily Fantasia 中直接呼叫 Steam 功能，
畢竟在 Nintendo Switch 上呼叫 Steam 函式是沒有意義的。
因此，還需要再建立一層抽象層來將「遊戲服務」與實際平台實作分離。

這是個相當有趣的主題，但我知道大多數人應該不會想看我講半天，
所以這裡放上一張「不太正確」的 UML 圖做簡略說明：

![LilyFantasiaGameService](LilyFantasiaGameService.png)

如果你真的想看詳細解釋的話……我知道你們應該不會問（笑）。

## 結語

我其實有在考慮 PvP 對戰功能，不過現階段應該沒時間實作。
